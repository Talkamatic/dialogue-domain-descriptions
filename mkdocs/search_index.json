{
    "docs": [
        {
            "location": "/", 
            "text": "A number of concepts need to be known to the developer when creating TDM Dialogue Domain Descriptions (DDDs).\n\n\nWe recommend new developers to start by reading \nthe introductory presentation\n by Alexander and studying the basic concepts below.\n\n\nAfter that, work through \nthe tutorial\n for hands on practice, or skip straight to \nthe example DDDs\n\n\nBasic concepts\n\n\nSome basic concepts in TDM are Actions, Questions, Answers and Feedback.\n\n\nActions\n\n\nAn action is requested by the user and performed by the system. It may or may not require a number of answers in order to be performed. Example:\n\n\nU\n Call.\n\n\n\n\nor\n\n\nU\n Call John.\n\n\n\n\nQueries\n\n\nA query is asked by the user or the system, when they want a piece of information. It can be formulated as a question, or as a request. Similar to an action, it may or may not require a number of answers in order to be answered.\n\n\nU\n What is John's number?\n\n\n\n\nor\n\n\nU\n Tell me John's number.\n\n\n\n\nAnswers\n\n\nAn answer is provided by the user or the system, providing information that is relevant for a question or request. When provided by the user, it can be resolving or not. If the question is about a contact, the following would be an answer:\n\n\nU\n John\n\n\n\n\nFeedback\n\n\nFeedback is given by the system to inform the user. For example that actions have been performed, that the system did not hear what the user said, etc.\n\n\nS\n Calling John.\n\n\n\n\nor\n\n\nS\n I did not hear.", 
            "title": "Introduction"
        }, 
        {
            "location": "/#basic-concepts", 
            "text": "Some basic concepts in TDM are Actions, Questions, Answers and Feedback.", 
            "title": "Basic concepts"
        }, 
        {
            "location": "/#actions", 
            "text": "An action is requested by the user and performed by the system. It may or may not require a number of answers in order to be performed. Example:  U  Call.  or  U  Call John.", 
            "title": "Actions"
        }, 
        {
            "location": "/#queries", 
            "text": "A query is asked by the user or the system, when they want a piece of information. It can be formulated as a question, or as a request. Similar to an action, it may or may not require a number of answers in order to be answered.  U  What is John's number?  or  U  Tell me John's number.", 
            "title": "Queries"
        }, 
        {
            "location": "/#answers", 
            "text": "An answer is provided by the user or the system, providing information that is relevant for a question or request. When provided by the user, it can be resolving or not. If the question is about a contact, the following would be an answer:  U  John", 
            "title": "Answers"
        }, 
        {
            "location": "/#feedback", 
            "text": "Feedback is given by the system to inform the user. For example that actions have been performed, that the system did not hear what the user said, etc.  S  Calling John.  or  S  I did not hear.", 
            "title": "Feedback"
        }, 
        {
            "location": "/tutorial/", 
            "text": "Step 1. Create the boilerplate\n\n\nFirst we need to create the DDD boilerplate.\n\n\nmkdir ddd_root; cd ddd_root \ntdm_create_ddd.py BasicAction basic_action\n\n\n\n\nBefore your DDD can be used, it needs to be built.\n\n\ntdm_build.py --ddd basic_action -text-only\n\n\n\n\nTo make sure your DDD and all dependencies are working as intended, let's run interaction tests.\n\n\ntdm_test_interactions.py --ddd basic_action -L eng -f basic_action/test/interaction_tests_eng.txt\n\n\n\n\nRan 1 test in 0.386s\n\nOK\n\n\n\n\nThe test reports OK. We're ready to start adding dialogue to our DDD. \n\n\nStep 2. Interaction test\n\n\nSince we're working test driven, let's add an interaction test first.\n\n\nInteraction tests verifiy the dialogue, providing user utterances and specifying the expected system responses.\n\n\nModify \nbasic_action/test/interaction_tests_eng.txt\n, add a test for the new dialogue that we want to support. In this case, we want to make a call to John.\n\n\n--- call\nS\n What would you like to do?\nU\n call john\nS\n Calling John.\n\n\n\n\nLet's build and run the tests again to verify that they fail.\n\n\ntdm_build.py --ddd basic_action -text-only\ntdm_test_interactions.py --ddd basic_action -L eng -f basic_action/test/interaction_tests_eng.txt\n\n\n\n\nTDM will complain that it does not understand instead of placing the call to John.\n\n\ncall first-name:\nbasic_action/test/interaction_tests_eng.txt at line 7: system output\nExpected:\n- Calling John.\nGot:\n+ I heard you say call john. I don't understand. So, What would you like to do?\n\n\n\n\nThis happens because there's no notion of calling, and no notion of people, in the DDD.\n\n\nStep 3. Ontology\n\n\nThe ontology declares what users can do and talk about, much like header files. In order to call someone we need to add the notion of calling, and the notion of people, to the ontology.\n\n\nOur boilerplate ontology is basically empty, in \nbasic_action/ontology.xml\n.\n\n\n?xml version=\n1.0\n encoding=\nutf-8\n?\n\n\nontology name=\nBasicActionOntology\n\n\n/ontology\n\n\n\n\n\nWe extend it with an action to make calls, a contact \nsort\n and a predicate \nselected_contact\n so that we can select an individual of our contact sort. A dynamic sort means its individuals are decided during run time, through the service interface.\n\n\n?xml version=\n1.0\n encoding=\nutf-8\n?\n\n\nontology name=\nBasicActionOntology\n\n  \naction name=\ncall\n/\n\n  \nsort name=\ncontact\n dynamic=\ntrue\n/\n\n  \npredicate name=\nselected_contact\n sort=\ncontact\n/\n\n\n/ontology\n\n\n\n\n\nLet's build and run the tests again to see if we missed something.\n\n\ntdm_build.py --ddd basic_action -text-only\n\n\n\n\nWe receive a warning when generating the grammar.\n\n\nBuilding GF 3.3 for application 'basic_action'.\n[eng] Cleaning build directory 'build/eng'...Done.\n[eng] Generating GF 3.3 grammar.\nMissing grammar entry: How do speakers talk about the action call? Specify the utterance:\n\n  \naction name=\ncall\ncall\n/action\n\n\nAlternatively, you can specify several possible utterances in a list:\n\n  \naction name=\ncall\n\n    \none-of\n\n      \nitem\ncall one way\n/item\n\n      \nitem\ncall another way\n/item\n\n      \nitem\ncall \nslot predicate=\ncity\n type=\nindividual\n/\n/item\n/one-of\n\n  \n/action\n\n[eng] Asserting that included grammars are lower case...Done.\n[eng] Finished generating GF 3.3 grammar.\n[eng] Building GF 3.3 grammar.\n[eng] Finished building GF 3.3 grammar.\n[eng] Converting GF 3.3 grammar to python format...Done.\n[eng] Text-only, skipped building ASR language model.\n[eng] Copying build results from 'build/eng' to application directory...Done.\nFinished building GF 3.3 for application 'basic_action'.\n\n\n\n\nApparently, ontology entries require their corresponding grammar entries.\n\n\nBut the build still seems to have succeeded. What happens if we run the tests?\n\n\ntdm_test_interactions.py --ddd basic_action -L eng -f basic_action/test/interaction_tests_eng.txt\n\n\n\n\nNo difference, apparently.\n\n\ncall first-name:\nbasic_action/test/interaction_tests_eng.txt at line 7: system output\nExpected:\n- Calling John.\nGot:\n+ I heard you say call john. I don't understand. So, What would you like to do?\n\n\n\n\nHow about that grammar entry?\n\n\nStep 4. Grammar\n\n\nThe grammar defines what our users and system can say. Our previous build attempt told us to add an entry for the \ncall\n action. Let's look at the boilerplate, in \nbasic_action/grammar/grammar_eng.xml\n.\n\n\n?xml version=\n1.0\n encoding=\nutf-8\n?\n\n\ngrammar\n\n  \naction name=\ntop\nmain menu\n/action\n\n  \naction name=\nup\ngo back\n/action\n\n\n/grammar\n\n\n\n\n\nIt contains entries for the default actions \ntop\n and \nup\n. For now, let's extend it with the \ncall\n action.\n\n\n?xml version=\n1.0\n encoding=\nutf-8\n?\n\n\ngrammar\n\n  \naction name=\ntop\nmain menu\n/action\n\n  \naction name=\nup\ngo back\n/action\n\n  \naction name=\ncall\ncall\n/action\n\n\n/grammar\n\n\n\n\n\nLet's build and test.\n\n\ntdm_build.py --ddd basic_action -text-only\ntdm_test_interactions.py --ddd basic_action -L eng -f basic_action/test/interaction_tests_eng.txt\n\n\n\n\ncall first-name:\nbasic_action/test/interaction_tests_eng.txt at line 7: system output\nExpected:\n- Calling John.\nGot:\n+ The function is not implemented.\n\n\n\n\nTDM replies! It means we did something right but apparently we need to implement the functionality as well. We need to add a plan to our domain\n\n\nStep 5. Plan\n\n\nPlans group together what our users can talk about. The plan is executed in order to reach a goal, for example to perform an action. When talking about something in the plan, TDM infers which goal is being implied and puts it at the top of the agenda.\n\n\nLet's check the boilerplate, in \nbasic_action/domain.xml\n.\n\n\n?xml version=\n1.0\n encoding=\nutf-8\n?\n\n\ndomain name=\nBasicActionDomain\n is_super_domain=\ntrue\n\n  \ngoal type=\nperform\n action=\ntop\n\n    \nplan\n\n      \nforget_all/\n\n      \nfindout type=\ngoal\n/\n\n    \n/plan\n\n  \n/goal\n\n\n/domain\n\n\n\n\n\nWe get the top goal for free. Remember its grammar entry \nmain menu\n. This is the only goal on TDM's agenda at startup. It will make TDM ask us which goal we want to achieve. Remember the corresponding default interaction test.\n\n\n--- main menu\nS\n What would you like to do?\n\n\n\n\nAnyway, let's add a new goal and plan, corresponding to our \ncall\n action and \nselected_contact\n predicate. Extend the domain.\n\n\n?xml version=\n1.0\n encoding=\nutf-8\n?\n\n\ndomain name=\nBasicActionDomain\n is_super_domain=\ntrue\n\n  \ngoal type=\nperform\n action=\ntop\n\n    \nplan\n\n      \nforget_all/\n\n      \nfindout type=\ngoal\n/\n\n    \n/plan\n\n  \n/goal\n\n  \ngoal type=\nperform\n action=\ncall\n\n    \nplan\n\n      \nfindout type=\nwh_question\n predicate=\nselected_contact\n/\n\n      \ndev_perform action=\nCall\n device=\nBasicActionDevice\n postconfirm=\ntrue\n/\n\n    \n/plan\n\n    \npostcond\ndevice_activity_terminated action=\nCall\n/\n/postcond\n\n  \n/goal\n\n\n/domain\n\n\n\n\n\nBuild.\n\n\ntdm_build.py --ddd basic_action -text-only\n\n\n\n\nBuilding GF 3.3 for application 'basic_action'.\n[eng] Cleaning build directory 'build/eng'...Done.\n[eng] Generating GF 3.3 grammar.\nMissing grammar entry: How does the system ask about selected_contact?\n\nExample:\n\n  \nquestion speaker=\nsystem\n predicate=\nselected_contact\n type=\nwh_question\nwhat is selected contact\n/question\n\n\n\n[eng] Asserting that included grammars are lower case...Done.\n[eng] Finished generating GF 3.3 grammar.\n[eng] Building GF 3.3 grammar.\n[eng] Finished building GF 3.3 grammar.\n[eng] Converting GF 3.3 grammar to python format...Done.\n[eng] Text-only, skipped building ASR language model.\n[eng] Copying build results from 'build/eng' to application directory...Done.\nFinished building GF 3.3 for application 'basic_action'.\n\n\n\n\nWe got a new warning about a missing grammar entry. When referencing a predicate in a plan, we apparently need to specify its grammar entry. Since we're using a findout, the grammar entry is to define how TDM should speak the corresponding \nquestion\n. Let's extend the grammar.\n\n\n?xml version=\n1.0\n encoding=\nutf-8\n?\n\n\ngrammar\n\n  \naction name=\ntop\nmain menu\n/action\n\n  \naction name=\nup\ngo back\n/action\n\n  \naction name=\ncall\ncall\n/action\n\n  \nquestion speaker=\nsystem\n predicate=\nselected_contact\n type=\nwh_question\nwho do you want to call\n/question\n\n\n/grammar\n\n\n\n\n\nBuild and test.\n\n\ntdm_build.py --ddd basic_action -text-only\ntdm_test_interactions.py --ddd basic_action -L eng -f basic_action/test/interaction_tests_eng.txt\n\n\n\n\ncall first-name:\nbasic_action/test/interaction_tests_eng.txt at line 7: system output\nExpected:\n- Calling John.\nGot:\n+ Who do you want to call?\n\n\n\n\nTDM replies again, great! But it didn't understand John. Actually, TDM's builtin robust parser ignored \"John\", finding the closest grammar match \"call\" instead.\n\n\nWe need to add an entity recognizer to our service interface. It needs to recognize entities of our \ncontact\n sort.\n\n\nStep 6. Service interface\n\n\nThe service interface is written in python, in \nbasic_action/device.py\n. This gives us freedom when implementing the entity recognizer, but it's under great responsibility. We can unexpectedly affect performance and stability if we're not careful. This entity recognizer should however be simple.\n\n\nLet's check the boilerplate.\n\n\nclass BasicActionDevice:\n    pass\n\n\n\n\nTotally empty, ok. Let's add the recognizer.\n\n\nfrom tdm.tdmlib import EntityRecognizer\n\nclass BasicActionDevice:\n    CONTACT_NUMBERS = {\n        \nJohn\n: \n0701234567\n,\n        \nLisa\n: \n0709876543\n,\n        \nMary\n: \n0706574839\n,\n        \nAndy\n: None,\n    }\n    class ContactRecognizer(EntityRecognizer):\n        def recognize_entity(self, string):\n            result = []\n            words = string.lower().split()\n            for contact in self.device.CONTACT_NUMBERS.keys():\n                if contact.lower() in words:\n                    recognized_entity = {\n                        \nsort\n: \ncontact\n,\n                        \ngrammar_entry\n: contact\n                    }\n                    result.append(recognized_entity)\n            return result\n\n\n\n\nLet's also modify our grammar to allow the one-shot call.\n\n\n?xml version=\n1.0\n encoding=\nutf-8\n?\n\n\ngrammar\n\n  \naction name=\ntop\nmain menu\n/action\n\n  \naction name=\nup\ngo back\n/action\n\n  \naction name=\ncall\n\n    \none-of\n\n      \nitem\ncall\n/item\n\n      \nitem\ncall \nslot sort=\ncontact\n/\n/item\n\n    \n/one-of\n\n  \n/action\n\n  \nquestion speaker=\nsystem\n predicate=\nselected_contact\n type=\nwh_question\nwho do you want to call\n/question\n\n\n/grammar\n\n\n\n\n\nBuild and test.\n\n\ntdm_build.py --ddd basic_action -text-only\ntdm_test_interactions.py --ddd basic_action -L eng -f basic_action/test/interaction_tests_eng.txt\n\n\n\n\nDeviceError: unknown device action: Call\n\n\n\n\nGreat, TDM appears to understand John. It wants to execute the \ncall\n action using our service interface, but could not find it. Let's add it.\n\n\nfrom tdm.tdmlib import EntityRecognizer, DeviceAction\n\nclass BasicActionDevice:\n    CONTACT_NUMBERS = {\n        \nJohn\n: \n0701234567\n,\n        \nLisa\n: \n0709876543\n,\n        \nMary\n: \n0706574839\n,\n        \nAndy\n: None,\n    }\n    class Call(DeviceAction):\n        PARAMETERS = [\nselected_contact.grammar_entry\n]\n        def perform(self, selected_contact):\n            number = self.device.CONTACT_NUMBERS.get(selected_contact)\n            # TODO: Implement calling\n            success = True\n            return success\n    class ContactRecognizer(EntityRecognizer):\n        def recognize_entity(self, string):\n            result = []\n            words = string.lower().split()\n            for contact in self.device.CONTACT_NUMBERS.keys():\n                if contact.lower() in words:\n                    recognized_entity = {\n                        \nsort\n: \ncontact\n,\n                        \ngrammar_entry\n: contact\n                    }\n                    result.append(recognized_entity)\n            return result\n\n\n\n\nSince we didn't modify any XML files since the last build, we don't need to build again until testing.\n\n\ntdm_test_interactions.py --ddd basic_action -L eng -f basic_action/test/interaction_tests_eng.txt\n\n\n\n\nException: failed to generate report(DeviceResultProposition(Call, [selected_contact(_contact_1_)], True, None), application_name='basic_action')\n\n\n\n\nIt still errors, but the error is new. Now that the action is executed, TDM tries to report it to the user. This happens because we said so in the plan. Remember \npostconfirm=\"true\"\n in the \ndev_perform\n entry of the plan?\n\n\n      \ndev_perform action=\nCall\n device=\nBasicActionDevice\n postconfirm=\ntrue\n/\n\n\n\n\n\nLet's add the \nreport\n grammar entry. We can reference the \nselected_contact\n predicate since its part of the \nfindout\n entries of the plan.\n\n\n?xml version=\n1.0\n encoding=\nutf-8\n?\n\n\ngrammar\n\n  \naction name=\ntop\nmain menu\n/action\n\n  \naction name=\nup\ngo back\n/action\n\n  \naction name=\ncall\n\n    \none-of\n\n      \nitem\ncall\n/item\n\n      \nitem\ncall \nslot sort=\ncontact\n/\n/item\n\n    \n/one-of\n\n  \n/action\n\n  \nquestion speaker=\nsystem\n predicate=\nselected_contact\n type=\nwh_question\nwho do you want to call\n/question\n\n  \nreport action=\nCall\n status=\nended\ncalling \nslot predicate=\nselected_contact\n/\n.\n/report\n\n\n/grammar\n\n\n\n\n\nBuild and test.\n\n\ntdm_build.py --ddd basic_action -text-only\ntdm_test_interactions.py --ddd basic_action -L eng -f basic_action/test/interaction_tests_eng.txt\n\n\n\n\nRan 1 test in 1.202s\n\nOK\n\n\n\n\nSuccess!\n\n\nStep 7. How to continue\n\n\nThis tutorial has illustrated how to implement the \nbasic action example\n.\n\n\nIn order to continue, go to the \nexamples\n section to find an example similar to your desired functionality. Steal the best ideas from there, adjusting them for yor domain. Remember to work test driven, adding a test first, then making it work.", 
            "title": "Step-by-step tutorial"
        }, 
        {
            "location": "/tutorial/#step-1-create-the-boilerplate", 
            "text": "First we need to create the DDD boilerplate.  mkdir ddd_root; cd ddd_root \ntdm_create_ddd.py BasicAction basic_action  Before your DDD can be used, it needs to be built.  tdm_build.py --ddd basic_action -text-only  To make sure your DDD and all dependencies are working as intended, let's run interaction tests.  tdm_test_interactions.py --ddd basic_action -L eng -f basic_action/test/interaction_tests_eng.txt  Ran 1 test in 0.386s\n\nOK  The test reports OK. We're ready to start adding dialogue to our DDD.", 
            "title": "Step 1. Create the boilerplate"
        }, 
        {
            "location": "/tutorial/#step-2-interaction-test", 
            "text": "Since we're working test driven, let's add an interaction test first.  Interaction tests verifiy the dialogue, providing user utterances and specifying the expected system responses.  Modify  basic_action/test/interaction_tests_eng.txt , add a test for the new dialogue that we want to support. In this case, we want to make a call to John.  --- call\nS  What would you like to do?\nU  call john\nS  Calling John.  Let's build and run the tests again to verify that they fail.  tdm_build.py --ddd basic_action -text-only\ntdm_test_interactions.py --ddd basic_action -L eng -f basic_action/test/interaction_tests_eng.txt  TDM will complain that it does not understand instead of placing the call to John.  call first-name:\nbasic_action/test/interaction_tests_eng.txt at line 7: system output\nExpected:\n- Calling John.\nGot:\n+ I heard you say call john. I don't understand. So, What would you like to do?  This happens because there's no notion of calling, and no notion of people, in the DDD.", 
            "title": "Step 2. Interaction test"
        }, 
        {
            "location": "/tutorial/#step-3-ontology", 
            "text": "The ontology declares what users can do and talk about, much like header files. In order to call someone we need to add the notion of calling, and the notion of people, to the ontology.  Our boilerplate ontology is basically empty, in  basic_action/ontology.xml .  ?xml version= 1.0  encoding= utf-8 ?  ontology name= BasicActionOntology  /ontology   We extend it with an action to make calls, a contact  sort  and a predicate  selected_contact  so that we can select an individual of our contact sort. A dynamic sort means its individuals are decided during run time, through the service interface.  ?xml version= 1.0  encoding= utf-8 ?  ontology name= BasicActionOntology \n   action name= call / \n   sort name= contact  dynamic= true / \n   predicate name= selected_contact  sort= contact /  /ontology   Let's build and run the tests again to see if we missed something.  tdm_build.py --ddd basic_action -text-only  We receive a warning when generating the grammar.  Building GF 3.3 for application 'basic_action'.\n[eng] Cleaning build directory 'build/eng'...Done.\n[eng] Generating GF 3.3 grammar.\nMissing grammar entry: How do speakers talk about the action call? Specify the utterance:\n\n   action name= call call /action \n\nAlternatively, you can specify several possible utterances in a list:\n\n   action name= call \n     one-of \n       item call one way /item \n       item call another way /item \n       item call  slot predicate= city  type= individual / /item /one-of \n   /action \n[eng] Asserting that included grammars are lower case...Done.\n[eng] Finished generating GF 3.3 grammar.\n[eng] Building GF 3.3 grammar.\n[eng] Finished building GF 3.3 grammar.\n[eng] Converting GF 3.3 grammar to python format...Done.\n[eng] Text-only, skipped building ASR language model.\n[eng] Copying build results from 'build/eng' to application directory...Done.\nFinished building GF 3.3 for application 'basic_action'.  Apparently, ontology entries require their corresponding grammar entries.  But the build still seems to have succeeded. What happens if we run the tests?  tdm_test_interactions.py --ddd basic_action -L eng -f basic_action/test/interaction_tests_eng.txt  No difference, apparently.  call first-name:\nbasic_action/test/interaction_tests_eng.txt at line 7: system output\nExpected:\n- Calling John.\nGot:\n+ I heard you say call john. I don't understand. So, What would you like to do?  How about that grammar entry?", 
            "title": "Step 3. Ontology"
        }, 
        {
            "location": "/tutorial/#step-4-grammar", 
            "text": "The grammar defines what our users and system can say. Our previous build attempt told us to add an entry for the  call  action. Let's look at the boilerplate, in  basic_action/grammar/grammar_eng.xml .  ?xml version= 1.0  encoding= utf-8 ?  grammar \n   action name= top main menu /action \n   action name= up go back /action  /grammar   It contains entries for the default actions  top  and  up . For now, let's extend it with the  call  action.  ?xml version= 1.0  encoding= utf-8 ?  grammar \n   action name= top main menu /action \n   action name= up go back /action \n   action name= call call /action  /grammar   Let's build and test.  tdm_build.py --ddd basic_action -text-only\ntdm_test_interactions.py --ddd basic_action -L eng -f basic_action/test/interaction_tests_eng.txt  call first-name:\nbasic_action/test/interaction_tests_eng.txt at line 7: system output\nExpected:\n- Calling John.\nGot:\n+ The function is not implemented.  TDM replies! It means we did something right but apparently we need to implement the functionality as well. We need to add a plan to our domain", 
            "title": "Step 4. Grammar"
        }, 
        {
            "location": "/tutorial/#step-5-plan", 
            "text": "Plans group together what our users can talk about. The plan is executed in order to reach a goal, for example to perform an action. When talking about something in the plan, TDM infers which goal is being implied and puts it at the top of the agenda.  Let's check the boilerplate, in  basic_action/domain.xml .  ?xml version= 1.0  encoding= utf-8 ?  domain name= BasicActionDomain  is_super_domain= true \n   goal type= perform  action= top \n     plan \n       forget_all/ \n       findout type= goal / \n     /plan \n   /goal  /domain   We get the top goal for free. Remember its grammar entry  main menu . This is the only goal on TDM's agenda at startup. It will make TDM ask us which goal we want to achieve. Remember the corresponding default interaction test.  --- main menu\nS  What would you like to do?  Anyway, let's add a new goal and plan, corresponding to our  call  action and  selected_contact  predicate. Extend the domain.  ?xml version= 1.0  encoding= utf-8 ?  domain name= BasicActionDomain  is_super_domain= true \n   goal type= perform  action= top \n     plan \n       forget_all/ \n       findout type= goal / \n     /plan \n   /goal \n   goal type= perform  action= call \n     plan \n       findout type= wh_question  predicate= selected_contact / \n       dev_perform action= Call  device= BasicActionDevice  postconfirm= true / \n     /plan \n     postcond device_activity_terminated action= Call / /postcond \n   /goal  /domain   Build.  tdm_build.py --ddd basic_action -text-only  Building GF 3.3 for application 'basic_action'.\n[eng] Cleaning build directory 'build/eng'...Done.\n[eng] Generating GF 3.3 grammar.\nMissing grammar entry: How does the system ask about selected_contact?\n\nExample:\n\n   question speaker= system  predicate= selected_contact  type= wh_question what is selected contact /question \n\n\n[eng] Asserting that included grammars are lower case...Done.\n[eng] Finished generating GF 3.3 grammar.\n[eng] Building GF 3.3 grammar.\n[eng] Finished building GF 3.3 grammar.\n[eng] Converting GF 3.3 grammar to python format...Done.\n[eng] Text-only, skipped building ASR language model.\n[eng] Copying build results from 'build/eng' to application directory...Done.\nFinished building GF 3.3 for application 'basic_action'.  We got a new warning about a missing grammar entry. When referencing a predicate in a plan, we apparently need to specify its grammar entry. Since we're using a findout, the grammar entry is to define how TDM should speak the corresponding  question . Let's extend the grammar.  ?xml version= 1.0  encoding= utf-8 ?  grammar \n   action name= top main menu /action \n   action name= up go back /action \n   action name= call call /action \n   question speaker= system  predicate= selected_contact  type= wh_question who do you want to call /question  /grammar   Build and test.  tdm_build.py --ddd basic_action -text-only\ntdm_test_interactions.py --ddd basic_action -L eng -f basic_action/test/interaction_tests_eng.txt  call first-name:\nbasic_action/test/interaction_tests_eng.txt at line 7: system output\nExpected:\n- Calling John.\nGot:\n+ Who do you want to call?  TDM replies again, great! But it didn't understand John. Actually, TDM's builtin robust parser ignored \"John\", finding the closest grammar match \"call\" instead.  We need to add an entity recognizer to our service interface. It needs to recognize entities of our  contact  sort.", 
            "title": "Step 5. Plan"
        }, 
        {
            "location": "/tutorial/#step-6-service-interface", 
            "text": "The service interface is written in python, in  basic_action/device.py . This gives us freedom when implementing the entity recognizer, but it's under great responsibility. We can unexpectedly affect performance and stability if we're not careful. This entity recognizer should however be simple.  Let's check the boilerplate.  class BasicActionDevice:\n    pass  Totally empty, ok. Let's add the recognizer.  from tdm.tdmlib import EntityRecognizer\n\nclass BasicActionDevice:\n    CONTACT_NUMBERS = {\n         John :  0701234567 ,\n         Lisa :  0709876543 ,\n         Mary :  0706574839 ,\n         Andy : None,\n    }\n    class ContactRecognizer(EntityRecognizer):\n        def recognize_entity(self, string):\n            result = []\n            words = string.lower().split()\n            for contact in self.device.CONTACT_NUMBERS.keys():\n                if contact.lower() in words:\n                    recognized_entity = {\n                         sort :  contact ,\n                         grammar_entry : contact\n                    }\n                    result.append(recognized_entity)\n            return result  Let's also modify our grammar to allow the one-shot call.  ?xml version= 1.0  encoding= utf-8 ?  grammar \n   action name= top main menu /action \n   action name= up go back /action \n   action name= call \n     one-of \n       item call /item \n       item call  slot sort= contact / /item \n     /one-of \n   /action \n   question speaker= system  predicate= selected_contact  type= wh_question who do you want to call /question  /grammar   Build and test.  tdm_build.py --ddd basic_action -text-only\ntdm_test_interactions.py --ddd basic_action -L eng -f basic_action/test/interaction_tests_eng.txt  DeviceError: unknown device action: Call  Great, TDM appears to understand John. It wants to execute the  call  action using our service interface, but could not find it. Let's add it.  from tdm.tdmlib import EntityRecognizer, DeviceAction\n\nclass BasicActionDevice:\n    CONTACT_NUMBERS = {\n         John :  0701234567 ,\n         Lisa :  0709876543 ,\n         Mary :  0706574839 ,\n         Andy : None,\n    }\n    class Call(DeviceAction):\n        PARAMETERS = [ selected_contact.grammar_entry ]\n        def perform(self, selected_contact):\n            number = self.device.CONTACT_NUMBERS.get(selected_contact)\n            # TODO: Implement calling\n            success = True\n            return success\n    class ContactRecognizer(EntityRecognizer):\n        def recognize_entity(self, string):\n            result = []\n            words = string.lower().split()\n            for contact in self.device.CONTACT_NUMBERS.keys():\n                if contact.lower() in words:\n                    recognized_entity = {\n                         sort :  contact ,\n                         grammar_entry : contact\n                    }\n                    result.append(recognized_entity)\n            return result  Since we didn't modify any XML files since the last build, we don't need to build again until testing.  tdm_test_interactions.py --ddd basic_action -L eng -f basic_action/test/interaction_tests_eng.txt  Exception: failed to generate report(DeviceResultProposition(Call, [selected_contact(_contact_1_)], True, None), application_name='basic_action')  It still errors, but the error is new. Now that the action is executed, TDM tries to report it to the user. This happens because we said so in the plan. Remember  postconfirm=\"true\"  in the  dev_perform  entry of the plan?         dev_perform action= Call  device= BasicActionDevice  postconfirm= true /   Let's add the  report  grammar entry. We can reference the  selected_contact  predicate since its part of the  findout  entries of the plan.  ?xml version= 1.0  encoding= utf-8 ?  grammar \n   action name= top main menu /action \n   action name= up go back /action \n   action name= call \n     one-of \n       item call /item \n       item call  slot sort= contact / /item \n     /one-of \n   /action \n   question speaker= system  predicate= selected_contact  type= wh_question who do you want to call /question \n   report action= Call  status= ended calling  slot predicate= selected_contact / . /report  /grammar   Build and test.  tdm_build.py --ddd basic_action -text-only\ntdm_test_interactions.py --ddd basic_action -L eng -f basic_action/test/interaction_tests_eng.txt  Ran 1 test in 1.202s\n\nOK  Success!", 
            "title": "Step 6. Service interface"
        }, 
        {
            "location": "/tutorial/#step-7-how-to-continue", 
            "text": "This tutorial has illustrated how to implement the  basic action example .  In order to continue, go to the  examples  section to find an example similar to your desired functionality. Steal the best ideas from there, adjusting them for yor domain. Remember to work test driven, adding a test first, then making it work.", 
            "title": "Step 7. How to continue"
        }, 
        {
            "location": "/examples/", 
            "text": "Below are examples for you to imitate. Find one that matches your desired functionality and start stealing ideas.\n\n\nRemember to work test driven, adding one test at a time, then making it work, according to the \ntutorial\n.\n\n\nThe source code of all examples is available on \nGitHub\n.\n\n\nBasic action\n\n\nThis example is featured in the \ntutorial\n.\n\n\nLet your user do an action, using an \nentity recognizer\n for its \nfindout\n. In this case, call a contact where the contact name is the recognized entity.\n\n\nU\n Call John\nS\n Calling John.\n\n\n\nThis is an example of the basic \naction\n, \nanswer\n and \nfeedback\n concepts in TDM. It shows what is needed in order to perform an \naction\n that you implement yourself in the python \nservice interface\n. In addition, it uses an \nentity recognizer\n to recognize contacts during run time.\n\n\nBasic query\n\n\nLet your user ask a question. While similar to the \nbasic action\n example, a query lets the system speak an answer to a question rather than performing an action. In this case, it answers what phone number a contact has.\n\n\nU\n What is John's number?\nS\n John's number is 0701234567.\n\n\n\nThis is an example of the basic \nquery\n and \nanswer\n concepts in TDM. It shows what is needed in order to ask a \nquery\n that is answered by the system. You implement the answer logic yourself in the python \nservice interface\n.\n\n\nParameter validation\n\n\nShould some actions or questions be unavailable, disallowed or prohibited for your user? Parameter validation makes it easy to decide at run-time. This example is based on the \nbasic action example\n, disallowing phone calls to contacts with no phone number.\n\n\nU\n Call Andy\nS\n Andy has no phone number.\n\n\n\nWhen a service is queried for parameters to actions and queries, the parameter is validated against all matching validators. If invalid, a specific grammar entry is used to provide system feedback and the answer is neglected.\n\n\nIncremental search\n\n\nIs your user looking for a single item in a set of many? Make sure your application asks just the perfect amount of questions to find one and only one match. In this case, contacts to call are searched with first and last names.\n\n\nU\n Call John\nS\n What's his last name?\nU\n Johnson\nS\n Calling John Johnson at 0702446698.\n\n\n\nIncremental search utilizes predicate features, which are declared in the ontology of the DDD. When a service is queried for individuals of the predicate, the features need to match. By asking the user to specify more features, the search can be narrowed down to finally match a single individual.\n\n\nAndroid\n\n\nIs your Android device performing the actions and recognizing the entities, for instance with the contacts of your phone book? Forward selected events to your Android frontend and do the job there.\n\n\nU\n Call John\nS\n Calling John.\n\n\n\nThis example combines the examples of action, query, parameter validation and entity recognition into one DDD. It forwards all the events to the frontend. It can be used together with the \nandroid-example\n, an Android app to showcase how your frontend hears, speaks and thinks.", 
            "title": "Examples"
        }, 
        {
            "location": "/examples/#basic-action", 
            "text": "This example is featured in the  tutorial .  Let your user do an action, using an  entity recognizer  for its  findout . In this case, call a contact where the contact name is the recognized entity.  U  Call John\nS  Calling John.  This is an example of the basic  action ,  answer  and  feedback  concepts in TDM. It shows what is needed in order to perform an  action  that you implement yourself in the python  service interface . In addition, it uses an  entity recognizer  to recognize contacts during run time.", 
            "title": "Basic action"
        }, 
        {
            "location": "/examples/#basic-query", 
            "text": "Let your user ask a question. While similar to the  basic action  example, a query lets the system speak an answer to a question rather than performing an action. In this case, it answers what phone number a contact has.  U  What is John's number?\nS  John's number is 0701234567.  This is an example of the basic  query  and  answer  concepts in TDM. It shows what is needed in order to ask a  query  that is answered by the system. You implement the answer logic yourself in the python  service interface .", 
            "title": "Basic query"
        }, 
        {
            "location": "/examples/#parameter-validation", 
            "text": "Should some actions or questions be unavailable, disallowed or prohibited for your user? Parameter validation makes it easy to decide at run-time. This example is based on the  basic action example , disallowing phone calls to contacts with no phone number.  U  Call Andy\nS  Andy has no phone number.  When a service is queried for parameters to actions and queries, the parameter is validated against all matching validators. If invalid, a specific grammar entry is used to provide system feedback and the answer is neglected.", 
            "title": "Parameter validation"
        }, 
        {
            "location": "/examples/#incremental-search", 
            "text": "Is your user looking for a single item in a set of many? Make sure your application asks just the perfect amount of questions to find one and only one match. In this case, contacts to call are searched with first and last names.  U  Call John\nS  What's his last name?\nU  Johnson\nS  Calling John Johnson at 0702446698.  Incremental search utilizes predicate features, which are declared in the ontology of the DDD. When a service is queried for individuals of the predicate, the features need to match. By asking the user to specify more features, the search can be narrowed down to finally match a single individual.", 
            "title": "Incremental search"
        }, 
        {
            "location": "/examples/#android", 
            "text": "Is your Android device performing the actions and recognizing the entities, for instance with the contacts of your phone book? Forward selected events to your Android frontend and do the job there.  U  Call John\nS  Calling John.  This example combines the examples of action, query, parameter validation and entity recognition into one DDD. It forwards all the events to the frontend. It can be used together with the  android-example , an Android app to showcase how your frontend hears, speaks and thinks.", 
            "title": "Android"
        }
    ]
}